#ifndef _FRAMEWORK_OS_H_#define _FRAMEWORK_OS_H_#include <semaphore.h>#include "define/framework_dll_definition.h"#include "loger/loger_definition.h"#include "IThread.h"#include "IQueuePool.h"const u16 MAX_THREAD_NAME_LENGTH = 255;typedef struct thread_info_t{    void* owner;    void (*clientCallBack)(void *);    struct queue_Info_t    {        IQueuePool* queuePool;        pthread_mutex_t mutex;        sem_t sem;    } queueInfo;} Thread_Info, *PThread_Info;// User should write the QueuePool for the program of yourselftemplate<class Q>class BaseThread : public IThread{public:    BaseThread():threadState_(EUninitilization), loger_("BaseThread")    {}    BaseThread(const char* name, void func(void*) = NULL, void* param = NULL,                const long stackSize = DEFAULT_STACK)                : threadState_(EUninitilization), loger_("BaseThread")    {        init_thread(name, func, param, stackSize);    }    ~BaseThread()    {        pthread_mutex_destroy(&threadInfo_.queueInfo.mutex);        sem_destroy(&threadInfo_.queueInfo.sem);        if (threadInfo_.queueInfo.queuePool != NULL)        {            delete threadInfo_.queueInfo.queuePool;        }        loger_ << debug << "ThreadID[" << CURRENT_THREAD_ID << "] " << "BaseThread::~BaseThread(), Thread:" << " closed";    }    IThread* holdWithParameters(const char* name, void func(void*) = NULL, void* param = NULL, const long stackSize =                DEFAULT_STACK)    {        init_thread(name, func, param, stackSize);        return this;    }    inline void joinThread() const    {        pthread_join(hThread_, NULL);    }    virtual void start()    {}    // Get current state of the thread.    virtual inline Thread_State getThreadState() const {return threadState_;}    // Change the state of thread.    virtual inline void setThreadState(Thread_State eState) {threadState_ = eState;}    // Return current thread's name.    inline const char* getThreadName() const {return threadName_;}    // Return loger for current thread.    inline Loger& getLoger() {return loger_;}    // Stop current thread.    virtual inline bool stop() const {return pthread_cancel(hThread_);}    // Queue data and send semaphore to thread.    virtual inline void send(void* data)    {        loger_ << debug << "ThreadID[" << CURRENT_THREAD_ID << "] " << "BaseThread: send data...";        threadInfo_.queueInfo.queuePool->put(data);        sem_post(&threadInfo_.queueInfo.sem);    }    // Nothing to do, it should be implemented by user class.    virtual inline void init_thread(const char* name, void func(void*), void* param,  const long stackSize)    {}protected:    typedef Q Queue_Base_Type;    Loger loger_;    pthread_t hThread_;    Thread_Info threadInfo_;    Thread_State threadState_;    char threadName_[MAX_THREAD_NAME_LENGTH];};#endif // _FRAMEWORK_OS_H_