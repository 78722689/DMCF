#ifndef _FRAMEWORK_OS_H_#define _FRAMEWORK_OS_H_#include <semaphore.h>#include "define/framework_dll_definition.h"#include "loger/loger_definition.h"#include "IThread.h"#include "IQueuePool.h"#include "dmcfos.h"#include "osDMCF.h"const u16 MAX_THREAD_NAME_LENGTH = 255;typedef struct thread_info_t{    void* owner;    void (*clientCallBack)(void *);    struct queue_Info_t    {        IQueuePool* queuePool;        DMCF_Sem* sem;    } queueInfo;} Thread_Info, *PThread_Info;// User should write the QueuePool for the program of yourselftemplate<class Q>class BaseThread : public IThread{public:    /*BaseThread():threadState_(EUninitilization), loger_("BaseThread"), osThread_(NULL), queue_(NULL)    {}*/    BaseThread(const char* name, void func(void*) = NULL, void* param = NULL,                const long stackSize = DEFAULT_STACK)                : threadState_(EUninitilization), loger_("BaseThread"), osThread_(NULL), queue_(new Queue_Base_Type)    {                snprintf(threadName_, MAX_THREAD_NAME_LENGTH, "%s", name);        threadInfo_.param = param;        threadInfo_.cb = func;                osThread_ = OSFactoryInstatnce->createDMCFOSThread(&threadInfo_);        queue_->setOwnerThread(this);        threadState_ = ECreated;    }    ~BaseThread()    {        delete osThread_;        delete queue_;        loger_ << debug << "ThreadID[" << DMCF_OSGetCurrentThread()  << "] " << "BaseThread::~BaseThread(), Thread:" << " closed";    }    IThread* holdWithParameters(const char* name)    {        //snprintf(threadName_, MAX_THREAD_NAME_LENGTH, "%s", name);                return this;    }    inline void joinThread() const    {        osThread_->join();    }    virtual void start()    {}    // Get current state of the thread.    virtual inline Thread_State getThreadState() const {return threadState_;}    // Change the state of thread.    virtual inline void setThreadState(Thread_State eState) {threadState_ = eState;}    // Return current thread's name.    inline const char* getThreadName() const {return threadName_;}    // Return loger for current thread.    inline Loger& getLoger() {return loger_;}    // Stop current thread.    virtual inline bool stop() const {return osThread_->stop();}    // Queue data and send semaphore to thread.    virtual inline void send(void* data)    {        loger_ << debug << "ThreadID[" << DMCF_OSGetCurrentThread()  << "] " << "BaseThread: send data...";        queue_->put(data);    }    // Retrun the handle of OS thread.    virtual inline void* getOSThreadHandle() const {return osThread_;}        inline void dispatch(){}protected:    typedef Q Queue_Base_Type;    Loger loger_;    //u32 hThread_;    dmcfOSThread* osThread_;    dmcf_threadinfo_t threadInfo_;    Queue_Base_Type* queue_;        Thread_State threadState_;    char threadName_[MAX_THREAD_NAME_LENGTH];};#endif // _FRAMEWORK_OS_H_