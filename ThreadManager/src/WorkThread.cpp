#include<pthread.h>#include "WorkThread.h"void WorkThread::init_thread(const char* name, void func(void*), void* param,  const long stackSize){    loger_ << debug << "BaseThread::init_thread(), Thread: " << name << " created";    snprintf(threadName_, MAX_THREAD_NAME_LENGTH, "%s", name);    threadInfo_.clientCallBack = func;    threadInfo_.owner = static_cast<void*>(this);    threadInfo_.queueInfo.queuePool = new Queue_Base_Type;    pthread_mutex_init(&threadInfo_.queueInfo.mutex, NULL);    sem_init(&threadInfo_.queueInfo.sem, 0, 0);    threadState_ = EInitlized;    if(pthread_create(&hThread_, NULL, WorkThread::processEntry, (void*)&threadInfo_) != 0)    {        loger_ << debug << "ThreadID[" << CURRENT_THREAD_ID << "] "             << "BaseThread::init_thread(): Create thread:" << name << " failed.";    }    loger_ << debug << "ThreadID[" << CURRENT_THREAD_ID << "] "             << "BaseThread::init_thread(): Create thread:" << name << " ThreadID:" <<hThread_;}void* WorkThread::processEntry(void* param){    Thread_Info *threadInfo = static_cast<Thread_Info*>(param);    IThread* owner = static_cast<IThread*>(threadInfo->owner);    owner->setThreadState(EBusy);// ...    bool isExit = false;    while(!isExit)    {        sem_wait(&threadInfo->queueInfo.sem);        IEvent* ev = static_cast<IEvent*>(threadInfo->queueInfo.queuePool->takeMessage());        if (ev && ev->getDestination())        {            ev->getDestination()->takeEvent(ev);        }        //isExit = true; // For test this thread.    }    std::cout << "Thread [" << CURRENT_THREAD_ID << "] exit......" << std::endl;    return NULL;}