#include<pthread.h>#include "WorkThread.h"void WorkThread::init_thread(const char* name, void func(void*), void* param,  const long stackSize){    loger_ << debug << "BaseThread::init_thread(), Thread: " << name << " created";    snprintf(threadName_, MAX_THREAD_NAME_LENGTH, "%s", name);    threadInfo_.clientCallBack = func;    threadInfo_.owner = static_cast<void*>(this);    threadInfo_.queueInfo.queuePool = new Queue_Base_Type;    DMCF_OSCreateSem(&threadInfo_.queueInfo.sem, 0);    threadState_ = EInitlized;    if (!DMCF_OSCreateThread(hThread_, WorkThread::processEntry, (void*)&threadInfo_))    {        loger_ << debug << "ThreadID[" << DMCF_OSGetCurrentThread() << "] "             << "WorkThread::init_thread(): Create thread:" << name << " failed.";    }    loger_ << debug << "ThreadID[" << DMCF_OSGetCurrentThread() << "] "             << "WorkThread::init_thread(): Create thread:" << name << " ThreadID:" <<hThread_;}void* WorkThread::processEntry(void* param){    Thread_Info *threadInfo = static_cast<Thread_Info*>(param);    IThread* owner = static_cast<IThread*>(threadInfo->owner);    owner->setThreadState(EBusy);    bool isExit = false;    while(!isExit)    {        DMCF_OSWaitSem(threadInfo->queueInfo.sem);        std::cout << "ThreadId:"<<DMCF_OSGetCurrentThread() <<" ProcessEntry: received sem" << std::endl;        IEvent* ev = static_cast<IEvent*>(threadInfo->queueInfo.queuePool->takeMessage());        if (ev && ev->getDestination())        {            ev->getDestination()->takeEvent(ev);        }        //isExit = true; // For test this thread.    }    std::cout << "Thread [" << DMCF_OSGetCurrentThread() << "] exit......" << std::endl;    return NULL;}