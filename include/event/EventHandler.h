#ifndef _EVENT_HANDLER_H_#define _EVENT_HANDLER_H_#include <iostream>#include <map>#include <list>#include "boost/optional.hpp"#include "boost/shared_ptr.hpp"#include "boost/make_shared.hpp"#include "IThread.h"/*** Base event*************************/namespace Event_Pkg{typedef int EVENT_ID;enum EventStatus{    eventConsumed,    eventNotConsumed};class IReactive;class IEvent{public:    virtual ~IEvent()    {}public:    virtual void setDestination(IReactive* dest) = 0;    virtual IReactive* getDestination() = 0;    virtual EVENT_ID getId() const  = 0;};class IReactive{public:    virtual ~IReactive()    {}public:    virtual bool gen(IEvent* ev) = 0;    virtual void sendEvent(IEvent* ev)=0;    virtual void takeEvent(IEvent* ev)=0;};class Event:public IEvent{public:    Event(EVENT_ID eventId = 0, IReactive* dest = 0) : id_(eventId), dest_(dest)    {}    ~Event(){}    inline EVENT_ID getId() const {return id_;}    inline void setDestination(IReactive* dest){dest_ = dest;}    inline IReactive* getDestination(){return dest_;}protected:    int id_; // event id    IReactive* dest_;};class Reactive : public IReactive{public:    Reactive(IThread* thread = NULL) : thread_(thread)    {}    ~Reactive(){}    void setThread(IThread* thread)    {        thread_ = thread;    }    virtual bool gen(IEvent* ev)    {        std::cout << "Reactive::gen..." << std::endl;                ev->setDestination(this);        thread_->send(static_cast<void*>(ev));    }    virtual void sendEvent(IEvent* ev)    {}    virtual void takeEvent(IEvent* ev)    {        std::cout << "Reactive::takeEvent..." << std::endl;        //takeEvent(ev);    } protected:    IThread* thread_;};} // end Event_Pkgusing namespace Event_Pkg;struct EventHandlerBase{    virtual ~EventHandlerBase(){};    virtual void takeEvent( IEvent* ev ) = 0;    virtual EVENT_ID getId() const = 0;};// Store client pointer and callback functemplate<typename SERVER, typename EVENT>class EventHandler : public EventHandlerBase{    typedef void (SERVER::*HANDLER_EVENT)(EVENT*);public:    EventHandler(SERVER *server, typename EventHandler::HANDLER_EVENT handler) :        m_server(server), m_handler(handler)    {}    virtual void takeEvent(IEvent *ev)    {        EVENT* cev = static_cast<EVENT*>(ev);        (m_server->*m_handler)(cev);  // Calling the callback func.    }    virtual EVENT_ID getId() const     {        EVENT e;        return e.getId();    }protected:        SERVER* m_server;        typename EventHandler::HANDLER_EVENT m_handler;        EVENT_ID m_id;};// It's probably the every event will be sent/received at the same time, so list to store such events.typedef std::list< boost::shared_ptr<EventHandlerBase > > EventHandlerList;// The behaviour likes Reactivetemplate< typename SERVER >class ReactiveAdapter: public Event_Pkg::Reactive{public:    ReactiveAdapter(){}    ~ReactiveAdapter(){}    template< typename EVENT>     void registerEventToReactive( void (SERVER::*handler)(EVENT *))    {        addToEventMap( makeEventHandler(handler) );    }    template< typename EVENT>     boost::shared_ptr< EventHandlerBase > makeEventHandler (void (SERVER::*handler)(EVENT *))    {        return boost::make_shared<EventHandler<SERVER, EVENT> >(static_cast< SERVER* >(this), handler);     }protected:    void addToEventMap(boost::shared_ptr<EventHandlerBase> handler)    {        std::map<EVENT_ID, EventHandlerList>::iterator iter = m_mapEvents.find(handler->getId());        if (iter == m_mapEvents.end())        {            iter = m_mapEvents.insert(std::make_pair(handler->getId(), EventHandlerList())).first;        }        iter->second.push_front(handler);    }private:    virtual void takeEvent(IEvent* ev)    {        Event_Pkg::EventStatus status = Event_Pkg::eventNotConsumed;        EVENT_ID id = ev->getId();        std::map<EVENT_ID, EventHandlerList>::iterator iter = m_mapEvents.find(id);        if (iter != m_mapEvents.end())        {            boost::shared_ptr<EventHandlerBase> eventHandler = iter->second.front();            eventHandler->takeEvent(ev);            status = Event_Pkg::eventConsumed;        }        // Default handling with Reactive.        if (status == Event_Pkg::eventNotConsumed) Event_Pkg::Reactive::takeEvent(ev);        delete ev;    }protected:    std::map<EVENT_ID, EventHandlerList> m_mapEvents;};#endif // _EVENT_HANDLER_H_